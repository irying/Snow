数组指针

```
int (*a)[10];
```

其实就是

```
typedef int *t;
t a[10];
```

`t`代表`int *`类型，`a`则是由这种类型的元素组成的数组。`int (*a)[10];`这个定义也可以拆成两句：

```
typedef int t[10];
t *a;
```

`t`代表由10个`int`组成的数组类型，`a`则是指向这种类型的指针。

```
typedef int t[10];
```

如何使用这种数组指针

```
int a[10];
int *p1 = a;
int (*pa)[10] = &a;
```

`a`是一个数组，在`&a`这个表达式中，数组名做左值，取整个数组的首地址赋给指针`pa`。

*该指针指向一个含有10个int 型元素的数组，恰好与a数组类型相同*

#### *数组名表示的是该数组的第一个元素的地址*

***<u>而对数组名取地址时，得到的将是该连续20个地址空间的首地址</u>**，虽然值相同，但意义不同。 **<u>&a[0]/p1/a表示的是一个4字节的内存块的首地址</u>**，而&a却表示20*4个字节的内存块首地址。 相当于此时对p1/a加1时增加的最小单位是4个字节的连续内存空间，也就是对应第二个元素，而对&a/pa加1是毫无意义的，增加是20*4个字节的连续内存空间，将会越界。



结论：

`*pa`就表示`pa`所指向的数组`a`，所以取数组的`a[0]`元素可以用表达式`(*pa)[0]`。注意到pa可以写成`pa[0]`，所以`(*pa)[0]`这个表达式也可以改写成pa[0][0]，`pa`就像一个二维数组的名字，它表示什么含义呢？下面把`pa`和二维数组放在一起做个分析。

`int a[5][10];`和`int (*pa)[10];`之间的关系同样类似于`int a[10];`和`int *pa;`之间的关系：`a`是由一种元素组成的数组，`pa`则是指向这种元素的指针。所以，如果`pa`指向`a`的首元素：

```
int a[5][10];
int (*pa)[10] = &a[0];
```

则`pa[0]`和`a[0]`取的是同一个元素，唯一比原来复杂的地方在于这个元素是由10个`int`组成的数组，而不是基本类型。这样，我们可以把`pa`当成二维数组名来使用，`pa[1][2]`和`a[1][2]`取的也是同一个元素，而且`pa`比`a`用起来更灵活，数组名不支持赋值、自增等运算，而指针可以支持，`pa++`使`pa`跳过二维数组的一行（40个字节），指向`a[1]`的首地址。



------------------------------------------------------------------------------------------------------------------

```
int arr[5][6] = {{1,2,3}}; //5行6列的数组，实际是一个含有5个元素的一维数组，每个元素又是一个含有6个int值的数组
int (*pp1)[6] = arr;  //pp1是一个指向含有6个int元素的数组的指针
int (*pp2)[5][6] = &arr;  //pp2是一个指向含有5行6列的二维数组的地址，即指向的是整个数组的数组
```

二维数组arr[i][j]会被解析成*(*(arr + i) + j)，arr依然是第一个元素的地址， <u>此处的第一个元素即可以表示arr[0][0]（即二维数组的第一个元素），也可以表示以行为元素的一维数组的第一个元素(arr + 0)（即第一行的6个元素），显然这两个地址是相同的。所以对arr增加1，即移到下一个 元素的地址，下一个元素即第二行。</u>arr的元素是含有6个int的一维数组，所以指向arr的指针类型也必须是含有 6个int的一维数组，所以*pp1的括号和后面的[6]必须要有。 pp2的解释与p2类似。

pp1/&arr[0]/arr

参考：https://akaedu.github.io/book/ch23s07.html

http://notes.maxwi.com/2016/03/15/array-pointer-function/



二维时

```C
#include <stdio.h>

typedef char (*PTR_TO_ARR)[30];
typedef int (*PTR_TO_FUNC)(int, int);

int max(int a, int b){
    return a>b ? a : b;
}

char str[3][30] = {
    "http://c.biancheng.net",
    "C语言中文网",
    "C-Language"
};

int main(){
    PTR_TO_ARR parr = &str[0];
    PTR_TO_FUNC pfunc = max;
    int i;

    printf("max: %d\n", (*pfunc)(10, 20));
    for(i=0; i<3; i++){
        printf("str[%d]: %s\n", i, *(parr+i));
    }

    return 0;
}
```

一维时

```C
1 warning generated.


#include <stdio.h>
typedef char (*PTR_TO_ARR)[30];
typedef int (*PTR_TO_FUNC)(int, int);
int max(int a, int b){
    return a>b ? a : b;
}
char str[30] = {'1','2','3'};
int main(){
    PTR_TO_ARR parr = &str; // 或者直接str
    PTR_TO_FUNC pfunc = max;
    int i;

    printf("max: %d\n", (*pfunc)(10, 20));
    for(i=0; i<3; i++){
        printf("str[%d]: %c\n", i, (parr[0])[i]);
    }
    return 0;
}
```




=============================================================

1、含义不同。

用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值。而一般我们的编译器采用的都是ASCII字符集。因此's'的含义其实和十进制数115的含义是一致的。

##### 而用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。

2、大小不同。

用单引号引起的一个字符大小就是一个字节。

##### 而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符'\0'。



-------------------------------------------------------------------

一、

C语言中，为什么字符串可以赋值给字符指针变量

char *p,a='5';
p=&a;                     //显然是正确的，
p="abcd";              //但为什么也可以这样赋值？？
问：一直理解不了为什么可以将字串常量赋值给字符指针变量，请各位指点！

 

答：

双引号做了3件事：  

1.申请了空间(在常量区)，存放了字符串 

2.在字符串尾加上了'/0'    

3.返回地址

你这里就是 返回的地址  赋值给了 p     



----------------------------------------------------

char *p = “hello”;

上边的表达式为什么可以，而把p换成数组，然后再赋值就不行了

解释：

字符串常量"hello"出现在一个表达式中时，"hello"表达式使用的值就是这些字符所存储的地址（在常量区），而不是这些字符本身。

所以，可以把字符串赋值给指向字符的指针p，而不能把字符串赋值给一个字符数组。 

**char a[10] = “hello”; //这样可以，这种情况是c语言初始化所支持的**

如果写成char a[10]

然后 a = “hello” 这样就错误了。  

同样是a数组，char a[10] = “hello”;这种是数组的初始化，和a[0] = ‘h’ a[1] = ‘e’…是一个道理

但是换成char a [10]

然后a = “hello”就不行了 “hello”赋值的值是一个地址，而a虽然也有地址，但是这与指针是不一样的，**指针的值是地址，而数组的值虽然也是地址，但是却是一个常量，所以不能给常量赋值。**