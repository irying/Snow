数组指针

```
int (*a)[10];
```

其实就是

```
typedef int *t;
t a[10];
```

`t`代表`int *`类型，`a`则是由这种类型的元素组成的数组。`int (*a)[10];`这个定义也可以拆成两句：

```
typedef int t[10];
t *a;
```

`t`代表由10个`int`组成的数组类型，`a`则是指向这种类型的指针。

```
typedef int t[10];
```

如何使用这种数组指针

```
int a[10];
int *p1 = ar;
int (*pa)[10] = &a;
```

`a`是一个数组，在`&a`这个表达式中，数组名做左值，取整个数组的首地址赋给指针`pa`。

*该指针指向一个含有10个int 型元素的数组，恰好与a数组类型相同*

#### *数组名表示的是该数组的第一个元素的地址*

***<u>而对数组名取地址时，得到的将是该连续20个地址空间的首地址</u>**，虽然值相同，但意义不同。 &a[0]/p1/a表示的是一个4字节的内存块的首地址，而&a却表示20*4个字节的内存块首地址。 相当于此时对pa/a加1时增加的最小单位是4个字节的连续内存空间，也就是对应第二个元素，而对&a/pa加1是毫无意义的，增加是20*4个字节的连续内存空间，将会越界。



结论：

`*pa`就表示`pa`所指向的数组`a`，所以取数组的`a[0]`元素可以用表达式`(*pa)[0]`。注意到pa可以写成`pa[0]`，所以`(*pa)[0]`这个表达式也可以改写成pa[0][0]，`pa`就像一个二维数组的名字，它表示什么含义呢？下面把`pa`和二维数组放在一起做个分析。

`int a[5][10];`和`int (*pa)[10];`之间的关系同样类似于`int a[10];`和`int *pa;`之间的关系：`a`是由一种元素组成的数组，`pa`则是指向这种元素的指针。所以，如果`pa`指向`a`的首元素：

```
int a[5][10];
int (*pa)[10] = &a[0];
```

则`pa[0]`和`a[0]`取的是同一个元素，唯一比原来复杂的地方在于这个元素是由10个`int`组成的数组，而不是基本类型。这样，我们可以把`pa`当成二维数组名来使用，`pa[1][2]`和`a[1][2]`取的也是同一个元素，而且`pa`比`a`用起来更灵活，数组名不支持赋值、自增等运算，而指针可以支持，`pa++`使`pa`跳过二维数组的一行（40个字节），指向`a[1]`的首地址。



------------------------------------------------------------------------------------------------------------------

```
int arr[5][6] = {{1,2,3}}; //5行6列的数组，实际是一个含有5个元素的一维数组，每个元素又是一个含有6个int值的数组
int (*pp1)[6] = arr;  //pp1是一个指向含有6个int元素的数组的指针
int (*pp2)[5][6] = &arr;  //pp2是一个指向含有5行6列的二维数组的地址，即指向的是整个数组的数组
```

二维数组arr[i][j]会被解析成*(*(arr + i) + j)，arr依然是第一个元素的地址， <u>此处的第一个元素即可以表示arr[0][0]（即二维数组的第一个元素），也可以表示以行为元素的一维数组的第一个元素(arr + 0)（即第一行的6个元素），显然这两个地址是相同的。所以对arr增加1，即移到下一个 元素的地址，下一个元素即第二行。</u>arr的元素是含有6个int的一维数组，所以指向arr的指针类型也必须是含有 6个int的一维数组，所以*pp1的括号和后面的[6]必须要有。 pp2的解释与p2类似。



参考：https://akaedu.github.io/book/ch23s07.html

http://notes.maxwi.com/2016/03/15/array-pointer-function/



二维时

```C
#include <stdio.h>

typedef char (*PTR_TO_ARR)[30];
typedef int (*PTR_TO_FUNC)(int, int);

int max(int a, int b){
    return a>b ? a : b;
}

char str[3][30] = {
    "http://c.biancheng.net",
    "C语言中文网",
    "C-Language"
};

int main(){
    PTR_TO_ARR parr = &str[0];
    PTR_TO_FUNC pfunc = max;
    int i;

    printf("max: %d\n", (*pfunc)(10, 20));
    for(i=0; i<3; i++){
        printf("str[%d]: %s\n", i, *(parr+i));
    }

    return 0;
}
```

一维时

```C
1 warning generated.


#include <stdio.h>
typedef char (*PTR_TO_ARR)[30];
typedef int (*PTR_TO_FUNC)(int, int);
int max(int a, int b){
    return a>b ? a : b;
}
char str[30] = {'1','2','3'};
int main(){
    PTR_TO_ARR parr = &str; // 或者直接str
    PTR_TO_FUNC pfunc = max;
    int i;

    printf("max: %d\n", (*pfunc)(10, 20));
    for(i=0; i<3; i++){
        printf("str[%d]: %c\n", i, (parr[0])[i]);
    }
    return 0;
}
```