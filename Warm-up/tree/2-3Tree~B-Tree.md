1. 二叉查找树不是严格的O(logN)，出现链表的时候就成了O(N);

2. AVL树是带有平衡条件的二叉查找树，一般要求每个节点的左子树和右子树的高度最多差1(空树的高度定义为-1)。

   在高度为h的AVL树中，最少的节点数**S(h)由S(h)=S(h-1)+S(h-2)+1**得出，其中S(0)=1，S(1)=2。

   (实现 http://www.cnblogs.com/linxiyue/p/3659448.html)

   ​

3.  2-3查找树的定义如下：

   1）要么为空，要么：

   2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。

   3） 对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。

   ​

   2-3树的查找效率与树的高度是息息相关的。

   ​	在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN

   ​	**在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN**

   距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。

   对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。

   (介绍：http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)

   ​

4. 2-3树实现起来比较复杂，一种简单实现2-3树的数据结构是红黑树（Red-Black Tree）

​      红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，**使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。**这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。

![](http://images.cnitblog.com/blog/94031/201403/270024368439888.png)

- 红色节点向左倾斜

- 一个节点不可能有两个红色链接

- 整个书完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。

- ###### 在最坏的情况下，红黑树的高度不超过2lgN

实现（http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html）



5.B-树

B树，**概括来说是一个节点可以拥有多于2个子节点的二叉查找树**。与自平衡二叉查找树不同，B-树为系统最优化**大块数据的读和写操作**。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在**数据库**和**文件系统**。ß

  **一棵m阶的B树，或为空树，或为满足下列特征的m叉树：**

​    ①、树中每个结点至多有m棵子树；

​    ②、若根结点不是终端结点，则至少有2棵子树；

​    ③、除根之外，所有非终端结点至少有![img](http://img.blog.csdn.net/20140313134137546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlmZW5nem91/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)棵子树；

​    ④、所有的非终端结点中包含下列信息数据:

[n, C0, K0, C1, K1, C2, K2, ...., Kn-1, Cn]

​        其中：Ki[i=0,1，...，n-1]为关键字，且Ki<Ki+1[i=0, 1, ..., n-2]；Ci[i=0,1,...,n]为至上子树根结点的指针，且指针Ci所指子树中所有结点的关键字均小于Ki[i=0,1,...,n-1]，但都大于Ki-1[i=1,...,n-1]；

动图（http://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html）

实现（http://blog.csdn.net/qifengzou/article/details/21079325）

**根据第3和第4点，(m/2-1)<=key的个数<=m-1**

```
 B树是从空树起，逐个插入关键字而建立起来的，由于B树结点中的关键字个数num必须>=m/2-1，因此，每次插入一个关键字不是在树中添加一个终端结点，而是首先在最底层的某个非终端结点中插入一个关键字，若该结点的关键字个数不超过m-1，则插入完成，否则要进行结点的“分裂”。
```

  假设结点node的关键字个数num>max，则需进行分裂处理，其大体处理流程如下：

  1) 结点node以sidx关键字为分割点，索引(0 ~ sidx-1)关键字继续留在结点node中，索引(sidx+1 ~ num-1)关键字放入新结点node2中
  2) 而索引sidx关键字则插入node->parent中，再将新结点node2作为父结点新插入关键字的右孩子结点
  3) 判断插入node的sidx关键字后，node->parent的关键字个数num是否超过max，如果超过，则以parent为操作对象进行1)的处理；否则，处理结束。

![](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/2.png)



6.B+树：内节点不存储data，只存储key；叶子节点不存储指针。

![](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/3.png)

**B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，<u>但是每个节点的域和上限是一致的</u>，所以在实现中B-Tree往往对每个节点申请同等大小的空间。**

**一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关**



综合5，6讨论mysql索引

1.磁盘IO读取细节：

​	当需要从磁盘读取数据时，**系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。**为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做**寻道，所耗费时间叫做寻道时间**，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做**旋转时间**。



2.局部性原理与磁盘预读

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，**而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。**这样做的理论依据是计算机科学中著名的局部性原理：

**当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。**

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

**预读的长度一般为页（page）的整倍数**。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。



3.B-Tree和B+Tree作索引的比较

根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

**<u>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</u>**

B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

综上所述，用B-Tree作为索引结构效率是非常高的。

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：

dmax=floor(pagesize/(keysize+datasize+pointsize))dmax=floor(pagesize/(keysize+datasize+pointsize))

floor表示向下取整。**<u>由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</u>**

这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。



4.MyISAM和InnoDB

MyISAM引擎使用B+Tree作为索引结构，**叶节点的data域存放的是数据记录的地址**。下图是MyISAM索引的原理图:

![](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/8.png)



如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：

![](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/9.png)



在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。

**MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。**



第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。**而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。**这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

![](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/10.png)

第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，**InnoDB的所有辅助索引都引用主键作为data域**。例如，图11为定义在Col3上的一个辅助索引：

![](http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/11.png)

聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。