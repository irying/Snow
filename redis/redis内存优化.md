一句话总结就是：Redis用字典实现Hash键，字典内部有两个哈希表，哈希表有个table数组，里面是键值对。



1.高并发写入场景中，在条件允许的情况下建议**字符串长度控制在39字节以内**，减少创建redisObject内存分配次数从而提高性能。

```
与对象的数据内容相关，如果是整数直接存储数据，否则表示指向数据的指针。Redis在3.0之后对值对象是字符串且长度<=39字节的数据，内部编码为embstr类型，字符串sds和redisObject一起分配，从而只要一次内存操作。
```



2.当频繁压缩解压json等文本数据时，开发人员需要考虑压缩速度和计算开销成本，这里推荐使用google的Snappy压缩工具，在特定的压缩率情况下效率远远高于GZIP等传统压缩工具，且支持所有主流语言环境。



3.**对象共享池**指**Redis内部维护[0-9999]的整数对象池**。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

> #### 为什么开启maxmemory和LRU淘汰策略后对象池无效?
>
> LRU算法需要获取对象最后被访问时间，以便淘汰最长未访问数据，每个对象最后访问时间存储在redisObject对象的lru字段。对象共享意味着多个引用共享同一个redisObject，这时lru字段也会被共享，导致无法获取每个对象的最后访问时间。**如果没有设置maxmemory，直到内存被用尽Redis也不会触发内存回收，所以共享对象池可以正常工作。**
>
> 综上所述，共享对象池与maxmemory+LRU策略冲突，使用时需要注意。 对于**ziplist编码的值对象，即使内部数据为整数也无法使用共享对象池**，因为ziplist使用压缩且内存连续的结构，对象共享判断成本过高，ziplist编码细节后面内容详细说明。



4.指不一定把每份数据作为字符串整体存储，像json这样的数据可以使用hash结构，使用二级结构存储也能帮我们节省内存。

> 字符串对象是Redis内部最常用的数据类型。所有的键都是字符串类型， 值对象数据除了整数之外都使用字符串存储。比如执行命令:lpush cache:type “redis” “memcache” “tair” “levelDB” ，**Redis首先创建”cache:type”键字符串**，**然后创建链表对象，链表对象内再包含四个字符串对象**，排除Redis内部用到的字符串对象之外至少创建5个字符串对象。



5.当我们的存储只有10个元素的列表，当使用双向链表数据结构时，必然需要维护大量的内部字段如每个元素需要:前置指针，后置指针，数据指针等，造成空间浪费，如果采用连续内存结构的压缩列表(ziplist)，将会节省大量内存，而由于数据长度较小，**存取操作时间复杂度即使为O(n2)性能也可满足需求。**

| string | raw embstr int               | 动态字符串编码 优化内存分配的字符串编码整数编码  |
| ------ | ---------------------------- | ------------------------- |
| list   | linkedlist ziplist quicklist | 双向链表编码 压缩列表编码 3.2版本新的列表编码 |



6.主要因为intset编码必须存储整数，当集合内保存非整数数据时，无法使用intset实现内存优化。intset数据结构插入命令复杂度为O(n)，查询命令为O(log(n))

- ziplist
- 可以模拟双向链表结构，以O(1)时间复杂度入队和出队。
- 3) 新增删除操作涉及内存重新分配或释放，加大了操作的复杂性。
- 4) 读写操作涉及复杂的指针移动，最坏时间复杂度为O(n2)。



Redis自身实现的字符串结构有如下特点:

- O(1)时间复杂度获取：字符串长度，已用长度，未用长度。
- 可用于保存字节数组，支持安全的二进制数据存储。
- 内部实现空间预分配机制，降低内存再分配次数。
- 惰性删除机制，字符串缩减后的空间不释放，作为预分配空间保留。