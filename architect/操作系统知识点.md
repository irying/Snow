### 进程

在Unix术语中，一个可执行程序是一个机器指令及其数据的序列，一个进程是程序运行时的内存空间和设置。



数据和程序存储在磁盘文件中，程序在进程中运行，进程存在于用户空间，用户空间是存放运行的程序和它们的数据的一部分内存空间。Unix系统中的内存分为系统空间和用户空间，内存实际上就是一个字节系列，或者一个很大的数组。



nice值越小进程的优先级越高。















##### [调整linux内核尽量用内存，而不用swap](http://www.myjishu.com/?p=80)

### Linux内存机制



#### 作用

**虚拟内存最主要作用是让每个进程有独立的地址空间，其他进程空间访问不到，有安全性，另一方面，每个进程都认为自己独占整个虚拟地址空间，这样执行程序不必考虑其他地址冲突之类，有稳定性。**



还有个作用是从缓存的角度去思考的

对于CPU来说，它的目标存储器是物理内存，使用高速缓存做物理内存的缓存。

对于虚拟内存来说，它的目标存储器是磁盘空间，使用物理内容做磁盘的缓存，有些数据放在内存中，就不用老是从磁盘那里获取。

#### 机制

**所以，从缓存原理的角度来理解，在任何时刻，虚拟页的集合都分为3个不相交的子集：**

**1. 未分配的页，即没有任何数据和这些虚拟页关联，不占用任何磁盘空间**

**2. 缓存的页，即已经分配了的虚拟页，并且已经缓存在具体的物理页中**

**3. 未缓存的页，即已经为磁盘文件分配了虚拟页，但是还没有缓存到具体的物理页中**

​	作为物理内存的扩展，linux会在物理内存不足时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。

> 在磁盘上临时保存虚拟内存页面的可能是一个磁盘分区，也可能是一个磁盘文件，称为交换设备（Swap Device）。当物理内存不够用时，将一些不常用的物理页面中的数据临时保存到交换设备，然后这个物理页面就认为是空闲的了，可以重新分配给进程使用，这个过程称为换出（Pageout）。如果进程要用到被换出的页面，就从交换设备再加载回物理内存，这称为换入（Pagein）。换出和换入操作统称为换页（Paging）
>
> 
>
> Linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。
>
> 要深入了解linux内存运行机制，需要知道下面提到的几个方面：
>
> 1. Linux系统会不时的进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。
> 2. Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，linux内核根据”最近最经常使用“算法，仅仅将一些不经常使用的页面文件交换到虚拟 内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如，一个占用很大内存的进程运行时，需 要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面 文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不 用担心什么，只要知道是怎么一回事就可以了。
> 3. 交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页 面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽 然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。



**buffers是用来缓冲块设备做的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages，而cached是用来给文件做缓冲。**更通俗一点说：buffers主要用来存放目录里面有什么内容，文件的属性以及权限等等。而cached直接用来记忆我们打开过的文件和程序。



为了验证我们的结论是否正确，可以通过vi打开一个非常大的文件，看看cached的变化，然后再次vi这个文件，感觉一下两次打开的速度有何异同，是不是第二次打开的速度明显快于第一次呢？
接着执行下面的命令：

```
find /* -name  *.conf
```

看看buffers的值是否变化，然后重复执行find命令，看看两次显示速度有何不同。

### Swap配置对性能的影响

linux什么时候开始使用虚拟内存（swap)？

A.[root@wenwen ~]# cat /proc/sys/vm/swappiness

60

上面这个60代表物理内存在使用60%的时候才会使用swap

swappiness=0的时候表示最大限度使用物理内存，然后才是 swap空间，

swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。

通常情况下：

swap分区设置建议是内存的两倍 （内存小于等于4G时），如果内存大于4G，swap只要比内存大就行。另外尽量的将swappiness调低，这样系统的性能会更好。



> 我在设置mysql的时候，将
>
> my.cnf文件
>
> innodb_buffer_pool_size = 6G（我操作系统的内存就是6G，一般这个值设置为操作系统内存的80%）
>
> 这个值并不是设置的越大越好。**设置的过大，会导致system的swap空间被占用，导致操作系统变慢，从而减低sql查询的效率。**
>
> 这里你可以这么理解，当我将这个buffer_pool_size设置得过大，跟操作系统内存一样大的时候，我使用mysql,会在一段时间内调用大量的数据进内存，由于linux的内存机制，再根据最近最优的原则，将一部分数据筛选放入swap分区，而swap分区没有及时的清理掉数据，当再次调用其它数据的时候，又会将一部分数据筛选放入swap分区，可能会出现一个现象，就是物理内存还有剩余，甚至是空的，而swap分区却是满的。

分配太多的Swap空间会浪费磁盘空间，**而Swap空间太少，则系统会发生错误。如果系统的物理内存用光了，系统就会跑得很慢，但仍能运行；如果Swap空间用光了，那么系统就会发生错误。**例如，Web服务器能根据不同的请求数量衍生出多个服务进程（或线程），如果Swap空间用完，则服务进程无法启动，通常会出现“application is out of memory”的错误，严重时会造成服务进程的死锁。因此Swap空间的分配是很重要的。

[虚拟内存，虚拟内存地址，物理内存，物理内存地址](https://blog.csdn.net/fukaibo121/article/details/75105848)



理解了内存映射机制就可以理解几个重要的函数：

1. fork函数会创建带有独立虚拟地址空间的新进程，内核会为新进程创建各种数据结构，分配一个唯一的PID，把当前进程的mm_struct, area结构和页表都复制给新进程。两个进程的共享同样的区域，这些区域包括共享的内存映射和私有的内存映射。私有的内存映射区域都被标记为私有的写时拷贝。如果新建的进程对这些虚拟页做修改，那么会触发写时拷贝，为新的进程维护私有的虚拟地址空间。
2. mmap函数可以创建新的虚拟内存area,并把磁盘对象映射到新建的area。

mmap可以用作高效的操作文件的方式，直接把一个文件映射到内存，通过修改内存就相当于修改了磁盘文件，减少了普通文件操作的一次拷贝操作。普通文件操作时会先把文件内容从磁盘复制到内核空间管理的一块虚拟内存区域area，然后内核再把内容复制到用户空间管理的虚拟内存area。 mmap相当于创建了一个内核空间和用户空间共享的area，文件的内容只需要在这个area对应的物理内存和磁盘文件之间交换即可。

mmap也可以通过映射匿名文件的方式来分配内存空间。比如malloc当要求分配的内存大小超过了MMAP_THRESHOLD(默认128kb)时，会使用mmap私有的，匿名文件的方式来分配大块的内存空间。



### 内存映射

虚拟内存的目标存储器是磁盘，所以虚拟内存区域是和磁盘中的文件对应的。初始化虚拟内存区域的内容时，会把虚拟内存区域和一个磁盘文件对象对应起来，这个过程叫内存映射(memory mapping)。虚拟内存可以映射的磁盘文件对象包括两种：

1. 一个普通的磁盘文件，文件中的内容被分成页大小的块。因为按需进行页面调度，只有真正需要读取这些虚拟页时，才会交换到主存
2. 一个匿名文件，匿名文件是内核创建的，内容全是二进制0，它相当于一个占位符，不会产生实际的磁盘流量。映射到匿名文件中的页叫做请求二进制零的页(demand zero page)

