**0.理想：**我们通常衡量一个Web系统的吞吐率的指标是QPS（Query Per Second，每秒处理请求数），解决每秒数万次的高并发场景，这个指标非常关键。举个例子，我们假**设处理一个业务请求平均响应时间为100ms，同时，系统内有20台Apache的Web服务器，配置MaxClients为500个（表示Apache的最大连接数目）**。

那么，我们的Web系统的理论峰值QPS为（理想化的计算方式）：

20*500/0.1 = 100000 （10万QPS）



**1.现实：**Apache打开了越多的连接进程，CPU需要处理的上下文切换也越多，额外增加了CPU的消耗，然后就直接导致平均响应时间增加。因此上述的MaxClient数目，要根据CPU、内存等硬件因素综合考虑，绝对不是越多越好。**可以通过Apache自带的abench来测试一下，取一个合适的值**。然后，我们选择内存操作级别的存储的Redis，在高并发的状态下，存储的响应时间至关重要。

![](http://cms.csdnimg.cn/article/201411/28/547821ee2d1ee_middle.jpg)

**2.问题**：

其实在正常的非高并发的业务场景中，也有类似的情况出现，某个业务请求接口出现问题，响应时间极慢，将整个Web请求响应时间拉得很长，逐渐将Web服务器的可用连接数占满，其他正常的业务请求，无连接进程可用。

更可怕的题是，是用户的行为特点，系统越是不可用，用户的点击越频繁，恶性循环最终导致“雪崩”（其中一台Web机器挂了，导致流量分散到其他正常工作的机器上，再导致正常的机器也挂，然后恶性循环），将整个Web系统拖垮。



出现上面这个问题应该怎么办？

**3. 重启与过载保护**

如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候，**最好在入口层将流量拒绝，然后再将重启。如果是redis/memcache这种服务也挂了，重启的时候需要注意“预热”**，并且很可能需要比较长的时间。

秒杀和抢购的场景，流量往往是超乎我们系统的准备和想象的。这个时候，过载保护是必要的。如果检测到系统满负载状态，拒绝请求也是一种保护措施。在前端设置过滤是最简单的方式，但是，这种做法是被用户“千夫所指”的行为。更合适一点的是，**将过载保护设置在CGI入口层，快速将客户的直接请求返回**。



但最好的做法就是对上面的问题做好预防，在可能导致问题的方式上采取相应措施。

**1. 同一个账号，一次性发出多个请求**（down:加锁）

![](http://cms.csdnimg.cn/article/201411/28/5478221b71722_middle.jpg)

**2. 多个账号，一次性发送多个请求**

Down:a.验证码 b.禁止ip

**2.1. 多个账号，不同IP发送不同请求**

有一些是某些机构自己占据一批独立IP，然后做成一个随机代理IP的服务，有偿提供给这些“工作室”使用。还有一些更为黑暗一点的，就是通过木马黑掉普通用户的电脑，这个木马也不破坏用户电脑的正常运作，只做一件事情，就是转发IP包，普通用户的电脑被变成了IP代理出口。通过这种做法，黑客就拿到了大量的独立IP，然后搭建为随机IP服务，就是为了挣钱。

**僵尸账号也还是有一些共同特征的，例如账号很可能属于同一个号码段甚至是连号的，活跃度不高，等级低，资料不全等等。根据这些特点，适当设置参与门槛，例如限制参与秒杀的账号等级。通过这些业务手段，也是可以过滤掉一些僵尸号。**

#### 一个典型的场景

**2.2火车票的抢购**

高级的黄牛刷票时，在识别验证码的时候使用真实的人，**中间搭建一个展示验证码图片的中转软件服务，真人浏览图片并填写下真实验证码，返回给中转软件**。对于这种方式，验证码的保护限制作用被废除了，目前也没有很好的解决方案。

![](http://cms.csdnimg.cn/article/201411/28/547822ce2f038.jpg)

这里还有一个火车票的转让操作方式。大致的操作方式，**是先用买家的身份证开启一个抢票工具，持续发送请求，黄牛账号选择退票，然后黄牛买家成功通过自己的身份证购票成功。当一列车厢没有票了的时候，是没有很多人盯着看的**，况且黄牛们的抢票工具也很强大，即使让我们看见有退票，我们也不一定能抢得过他们哈。

![](http://cms.csdnimg.cn/article/201411/28/547822fbe13a0.jpg) 



**3.超发**

![](http://cms.csdnimg.cn/article/201411/28/54782328bb155_middle.jpg)



应对方法：

悲观锁，不好，每次都得等锁

![](http://cms.csdnimg.cn/article/201411/28/5478234d530bf_middle.jpg)



乐观锁

乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。

有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。

![](http://cms.csdnimg.cn/article/201411/28/547823d8e0db8_middle.jpg)