### 单体架构

有两个显著问题：敏捷开发和交付。

随着业务发展，模块越来越多，比如一个用户服务，被商城模块调用，又被教育模块调用，假如有一天，商城模块在操作用户表，因为商城同学代码不严谨，**导致用户表锁全表，教育模块一直拿不到数据，你就要等问题修复，锁释放了应用才恢复正常。**常常牵一发而动全身的感觉，

所有模块都运行在同一进程中，任何模块中的一个bug，比如内存泄漏都可能弄垮整个进程，非常影响应用的可用性。

庞大且复杂的单体应用的另一大问题就是**难以进行持续部署**。代码越来越多，加载文件越来越多，部署成功时间就越来越慢。**而且**，我只想更新某个某个模块的某一部分，你就不得不重新部署整个应用，有些bug本来是没有的，有的人可能也懒得全面测试，结果一上去，其他bug报了。

### 微服务

微服务把服务拆分了，就解决了这两个痛点，现在出问题也是单个服务出问题，其他服务跟它没关联的话就好好的。单个服务开发、选型、技术栈可以结合业务类型选择，可能以前单体的时候，可能都是php，或者都是java。现在如果你的服务需要批处理，并行运行，可以选go，如果有很多后台，可以选php或者python，都不影响其他服务。



独立部署



当然，微服务也会带来新问题，之前单体应用只有一个进程，现在微服务是多个进程，是个分布式系统。进程间的通信机制--RPC或者消息队列要考虑，各种服务实例不止一个，服务发现、服务配置、服务可用监控还要服务实例伸缩等服务治理也要做好，这些是基础措施的问题，还有个代码架构方面的，服务拆分策略问题。

### 进程间通信

一对一的交互模式有以下几种方式：

请求/响应：一个客户端向服务器端发起请求，等待响应，客户端期望此响应即时到达。在一个基于线程的应用中，等待过程可能造成线程阻塞。
通知（也就是常说的单向请求）：一个客户端请求发送到服务端，但是并不期望服务端响应。
请求/异步响应：客户端发送请求到服务端，服务端异步响应请求。客户端不会阻塞，而且被设计成默认响应不会立刻到达。
一对多的交互模式有以下几种方式：

发布/ 订阅模式：客户端发布通知消息，被零个或者多个感兴趣的服务消费。

发布/异步响应模式：客户端发布请求消息，然后等待从感兴趣服务发回的响应。

每个服务都是以上这些模式的组合。对某些服务，一个 IPC 机制就足够了；而对另外一些服务则需要多种 IPC 机制组合。下图展示了在用户叫车时，打车应用内的服务是如何交互的。

### 服务发现

在微服务应用中，服务实例的运行环境会动态变化，实例网络地址也是如此。因此，客户端为了访问服务必须使用服务发现机制。

#### 1.两种主要模式

服务发现有两种主要模式：客户端发现和服务端发现。在使用客户端服务发现的系统中，**客户端查询服务注册表，选择可用的服务实例，然后发出请求。**在使用服务端发现的系统中，**客户端通过路由转发请求，路由器查询服务注册表并转发请求到可用的实例。**

在一些部署环境中，需要使用 Netflix Eureka、etcd、Apache Zookeeper 等服务发现来设置自己的服务发现基础设施**。而另一些部署环境则内置了服务发现。例如，Kubernetes 和 Marathon 处理服务实例的注册和注销，它们也在每个集群主机上运行代理，这个代理具有服务端发现路由的功能。**

HTTP 反向代理和 NGINX 这样的负载均衡器能够用做服务器端的服务发现均衡器。服务注册表能够将路由信息推送到 NGINX，激活配置更新，譬如使用 Cosul Template。NGINX Plus 支持额外的动态配置机制，**能够通过 DNS 从注册表中获取服务实例的信息，并为远程配置提供 API。**

#### 2.3种实现

1.传统的放一台nginx

2.每个客户端代码（进程）里面带一个，不同语言不同实现

3.每个客户端主机加一个lb进程，代理，都是一样的，现在出现的server mesh



### 配置中心

以往

1.配置维护在各自的配置文件中，服务提供者上线的时候注册到注册中心，然后改了重新部署（改了IP端口之类的）。订阅者怎么办？

一个消费者去调用提供者的接口，会先经过一个rpc组件，这个rpc组件会去传提供者名字去注册中心拿到提供者的ip和端口，然后建立rpc连接。一般情况下，不会每次调用每次都去注册中心拿ip端口，所以会在本地建个缓存存储，一个hash，这个服务名对应的IP端口。这时候提供者的IP和端口变了，就是配置更改了，可以实时推过来，刷缓存；或者消费者定期拉，发现有变动就刷缓存。



可以建立个配置中心，统一格式统一管理。

### 不断进化的 API

服务的 API 会随着时间而不断变化。在单体应用中，经常会直接修改 API 并更新所有的调用者。但是在基于微服务的应用中，即使所有的 API 的使用者都在同一应用中，这种做法也困难重重，通常不能强制让所有客户端都与服务保持同步更新。此外，你可能会增量部署服务的新版本，这时旧版本会与新版本同时运行。了解这些问题的处理策略至关重要。
对 API 变化的处理方式与变化的大小有关。有的变化很小，并且可以兼容之前的版本；比如给请求或响应增加属性。在设计客户端和服务时，很有必要遵循健壮性原则。服务更新版本后，使用旧版 API 的客户端应该继续使用。服务为缺失的请求属性提供默认值，客户端则忽略任何额外的响应。使用 IPC 机制和消息格式能够让你轻松改进 API。

然而有时候，API 需要进行大规模改动，并且不兼容旧版本。鉴于不能强制让所有客户端立即升级，支持旧版 API 的服务还要再运行一段时间。如果你使用的是诸如 REST 这样的基于 HTTP 机制的 IPC，**一种方法就是将版本号嵌入到 URL 中，每个服务实例可以同时处理多个版本。另一种方法是部署不同实例，每个实例处理一个版本的请求。**

### 处理局部失败

在上一篇关于 API 网关的文章中，我们了解到，分布式系统普遍存在局部失败的问题。由于客户端和服务端是独立的进程，服务端可能无法及时响应客户端请求。服务端可能会因为故障或者维护而暂时不可用。服务端也可能会由于过载，导致对请求的响应极其缓慢。

以上篇文章中提及的产品页为例，假设推荐服务无法响应，客户端可能会由于无限期等待响应而阻塞。这不仅会导致很差的用户体验，并且在很多应用中还会占用之前的资源，比如线程；最终，如下图所示，运行时耗尽线程资源，无法响应。



### 网关

鉴权

接口聚合

分流

隔离

熔断

限流

降级

(Hysrix)



