 **2PC**

第1阶段：**投票请求阶段**

![](http://www.bo56.com/wp-content/uploads/2017/03/1.png)



1、事务询问  

​	协调者向所有参与者发送事务内容,询问是否可以提交事务内容，并等待各参与者的响应。

 2、 执行事务

​	参与者执行事务操作，并记录Undo 和 redo日志（这里的参与者已经执行了事务操作）

 3、 各参与者向协调者反馈事务询问响应。

​	如果参与者成功执行了事务操作，反馈YES，表示可以执行,否则反馈NO。阶段一则为投票阶段。各参与者尝试着执行事务并反馈结果

4、异常情况

​	在第一阶段，主要是事务管理者（经理）发起事务，让各个事务资源方（职员甲乙）确认资源是否满足，并做预处理（冻结）。资源方的操作有可能失败也可能成功。如，张三账户不足5元钱，没办法冻结，就是失败。资源方把操作结果反馈给事务管理者。

![](http://www.bo56.com/wp-content/uploads/2017/03/2.png)





第2阶段：**提交执行阶段**

![](http://www.bo56.com/wp-content/uploads/2017/03/3.png)

阶段二分两种情况：A、事务正常执行。B、事务执行失败

A、事务正常执行 

1. 所有参与者反馈YES，协调者向参与者节点发出commit请求。   
2. 参与者收到请求后正式执行提交操作并在完成提交之后释放在整个事务执行期间占用的事务资源。    
3. 参与者执行后反馈Ack消息。
4. 协调者接收到Ack消息后完成事务

B、如果过程中接收到一个或多个NO，事务执行失败

​      1、发送回滚请求。

​      2、事务回滚

​      3、反馈回滚结果

​      4、中断事务



![](http://www.bo56.com/wp-content/uploads/2017/03/4.png)



#### 缺点：

**2pc是强一致性算法，优点是实现简单，缺点也很明显，其中最大的问题是同步阻塞，在第二阶段开始，协调者等待参与者返回的过程中，<u>一旦某个参与者不能及时返回，整个系统会阻塞</u>，同时还有一个问题就是如果协调者在发出commit请求后某个参与者crash或者网络断开，那么就会出现数据不一致的情况。**

🤓**阻塞**：

​	两阶段提交，要有一个事务管理者协调各方的操作。各方对资源的占用要到整个事务结束后才能释放。这样会影响事务的效率。当并发量大的时候，系统的性能会严重下滑。

​	事务管理者和资源方存在通信。有可能存在通信不通畅。如，职员甲接受到扣钱的命令后，职员甲扣完了钱。由于电话故障等原因，导致没办法通知经理已经操作成功。因此，各方还要处理通信超时问题。

**🤓单点：**

​	整个流程需要事务管理者协调各个资源方进行操作。但是，事务管理者可能出现问题。导致没办法进行协调。如，经理生病了。

🤓**幂等性问题：**

​	可能存在对资源方重复调用的情况。这种情况下，资源方被调用多次和调用一次的效果要一样。如上例中，经理第二次通知职员甲扣5元的时候，职员甲要像上次一样，告诉经理扣款已经完成。但是，职员甲不能再进行扣款的动作。

​	也有可能协调者通知过去了，但参与者挂了，协调者也挂了，不知道数据到底提交了没。





**3PC**

![](http://img.blog.csdn.net/20160116195621989)



3pc是2pc的改进版本，主要是给协调者和参与者都引入了**超时机制，同时在第一阶段和第二阶段过程中加入了一个准备阶段**，保障了数据的一致性。

**阶段一：canCommit**

协调者向参与者发送canCommit消息和事务信息,参与者收到后，会判别自己是否可以执行该事务,如果可以执行就返回 yes,不可以则返回no.如果协调者收到任何一个no或者参与者超时，事务终止,同时会通知参与者事务终止，**只有在超时时间内收到所有yes，才能进入下一阶段**。（相对于参与者来说，在反馈完第一阶段的canCommit后，如果等待协调者发送preCommit也超时的话也会终止事务）



**阶段二：preCommit**

  本阶段协调者会发送preCommit消息给所有参与者，所有参与者收到后会开始执行事务，并记录undo和redo日志，返回ACK消息。

**阶段三：doCommit**

​             协调者只有在接收到所有ACK消息后会发送doCommit，否则会给参与者发出终止消息，事务回滚。（相对于参与者来说，只要接受到一个preCommit消息并返回了ACK，如果此时协调者崩溃或者超时，各个参与者则会继续完成这次commit。所以在第三阶段，如果是协调者出错参与者没错的情况下，参与者会继续完成本次提交;如果是协调者没错，参与者出错，则本次事务终止。）

****

**总结：3pc对比2pc来说增强了数据一致性， 同时引入了双方超时机制，减小了阻塞。但是缺点依旧存在，主要是无法避免网络分区（网络分区：在网络不好的情况下，高延迟被区分成失败）问题，因为3pc采用了失败-停止的模式,所以一旦网络延迟高就会失败。**

(引入个watchdog)

coordinator如果在发起提议后宕机，那么participant将进入阻塞(block)状态、一直等待coordinator回应以完成该次决议。这时需要另一角色把系统从不可结束的状态中带出来，我们把新增的这一角色叫协调者备份(coordinator watchdog)。coordinator宕机一定时间后，watchdog接替原coordinator工作，通过问询(query) 各participant的状态，决定阶段2是提交还是中止。这也要求 coordinator/participant 记录(logging)历史状态，以备coordinator宕机后watchdog对participant查询、coordinator宕机恢复后重新找回状态。





participant如果在不同阶段宕机，我们来看看3PC如何应对：

- **阶段1**: coordinator或watchdog未收到宕机participant的vote，直接中止事务；<u>宕机的participant恢复后，读取logging发现未发出赞成vote，自行中止该次事务</u>
- **阶段2**: coordinator未收到宕机participant的precommit ACK，但因为之前已经收到了宕机participant的赞成反馈(不然也不会进入到阶段2)，coordinator进行commit；watchdog可以通过问询其他participant获得这些信息，过程同理；宕机的participant恢复后发现收到precommit或已经发出赞成vote，则自行commit该次事务
- **阶段3**: 即便coordinator或watchdog未收到宕机participant的commit ACK，也结束该次事务；宕机的participant恢复后发现收到commit或者precommit，也将自行commit该次事务

因为有了准备提交(prepare to commit)阶段，3PC的事务处理延时也增加了1个RTT，变为3个RTT(propose+precommit+commit)，但是它防止participant宕机后整个系统进入阻塞态，增强了系统的可用性，对一些现实业务场景是非常值得的。



#### 消息中间件

![](http://www.bo56.com/wp-content/uploads/2017/03/5.png)



基于消息的分布式事务实现中，引入了消息中间件（助理），负责消息的传递和事务执行状态的询问。这样就降低了系统间的耦合度。

为什么职员甲在进行扣款前，**要告诉助理？主要是怕自己扣款成功了，又忘记告诉助理。这个时候，助理也就没办法通知职员乙操作了。告诉助理后，如果职员甲忘记了，助理可以询问职员甲，是否执行成功。**进而决定是否该通知职员乙进行加钱操作。

如果职员甲扣款失败，则应该通知助理。助理在这种情况下，就不英再通知职员乙加钱。

#### 基于消息实现的问题

基于消息的分布式事务实现，讲究的是最终一致性。也即所有的本地事务执行完毕后，整个状态的一致。

**整个事务一般不会有回滚操作。如，当职员乙操作失败的时候，职员应该是再次通知职员乙重试。**

