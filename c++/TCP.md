#### 从面试问题出发

- TCP协议和UDP协议的异同？
- TCP协议是如何保证可靠性的？
- 三次握手和四次挥手是如何实现的？
- 拥塞控制是如何实现的？
- 流量控制是如何实现的？
- 滑动窗口协议的原理？



### UDP（用户数据报协议）详解

##### 1.面向报文

**面向报文**的传输方式是**应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。**因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。**UDP对应用层交下来的报文，既不合并，也不拆分**，而是保留这些报文的边界。

##### 2.无连接

通信前不需要建立连接，通信结束也无需释放连接。

##### 3.不可靠

它是尽力而为交付，不能确保每一个数据报都送达。

**TCP 丢包会自动重传，UDP 不会(任何必需的可靠性必须由应用层来提供)**。 TCP 可靠性由三个机制保证：1. 序号（TCP 报文的序号）2. 确认（ACK 机制）3. 重传（超时或者冗余的 ACK）

**报文在传输过程中可能会乱序，后发送的报文可能会先到达，TCP 会对其进行重新排序，UDP 不会。**

##### 4.UDP没有拥塞控制

UDP始终以恒定的速率发送数据，并不会根据网络拥塞情况对发送速率作调整。这种方式有利有弊。

弊端：网络拥塞时有些报文可能会丢失，因此UDP不可靠。

优点：有些使用场景允许报文丢失，如：直播、语音通话，但对实时性要求很高，此时UDP还是很有用武之地的。

##### 5.UDP支持一对一、一对多、多对多、多对一通信

##### 6.UDP首部开销小，只有8字节。

而TCP头部至少由20字节，相比于TCP要高效很多。

![](http://my.csdn.net/uploads/201204/10/1334069453_5734.png)



#### 对比UDP，TCP主要的思考点

- TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。**TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。**如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

面向连接就有个问题，叫**粘包**

> TCP无边界，造成对采用TCP协议发送的数据进行接收比较麻烦，在接收的时候易出现粘包，即发送方发送的若干包数据到接收方接收时粘成一包。由于TCP是流协议，对于一个socket的包，如发送 10AAAAABBBBB两次，由于网络原因第一次又分成两次发送， 10AAAAAB和BBBB，如果接包的时候先读取10(包长度)再读入后续数据，**当接收得快，发送的慢时**，就会出现先接收了 10AAAAAB,会解释错误 ,再接到BBBB10AAAAABBBBB，也解释错误的情况。这就是TCP的粘包。

##### 怎么解决这个问题呢

```
一、对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；
二、对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
三、由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。
```



- 三次握手和四次握手

三次握手里面有**几个关键字和内容**

![](https://leanote.com/api/file/getImage?fileId=589ed2daab644113b3000658)

![](https://leanote.com/api/file/getImage?fileId=589efc15ab644113b300082e)

#### 几个关键字和内容

##### 1.序号seq

当前TCP数据报数据部分的第一个字节的序号。**我们知道，TCP是面向字节的，它会对发送的每一个字节进行编号，而且不同数据报之间是连续编号的。**

由于本字段4字节，可以给[0,2^32-1]个字节进行编号（大约4G），而且序号循环使用，当发送完2^32-1个字节后，序号又从0开始。一般来说，当2^32-1个字节被发送的时候，前面的字节早就发送成功了，因此序号可以循环使用。

##### 2.确认号ack(第二次握手ack=seq+1)

表示当前主机作为接收端时，期望接收的下一个字节的编号是多少。也表示，当前主机已经**正确**接收的最后一个字节序号+1。

##### 3.数据偏移（报文长度）

它表明了数据报头部的长度。

##### 4.标识符

TCP有7种标识符，用于表示TCP报文的性质。它们只能为0或1。

- URG=1 当URG字段被置1，表示本数据报的数据部分包含紧急信息，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。如control+c：这个命令要求操作系统立即停止当前进程。此时，这条命令就会存放在数据包数据部分的开头，并由紧急指针标识命令的位置，并URG字段被置1。
- ACK=1 ACK被置1后确认号字段才有效。此外，TCP规定，在连接建立后传送的所有报文段都必须把ACK置1。
- PSH=1 **当接收方收到PSH=1的报文后，会立即将数据交付给应用程序，而不会等到缓冲区满后再提交。一些交互式应用需要这样的功能，降低命令的响应时间。**
- **RST=1 当该值为1时，表示当前TCP连接出现严重问题，必须要释放重连。**
- SYN=1 SYN在建立连接时使用。当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。
- FIN=1 FIN=1表示此报文段是一个释放连接的请求报文。



**第一次握手**

客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。

- PS1：SYN=1，ACK=0表示该报文段为连接请求报文。
- PS2：x为本次TCP通信的字节流的初始序号。 TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。该应答发送完成后便进入SYN-RCVD状态。

- PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。
- PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。
- PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1。

客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！



**为什么连接建立需要三次握手，而不是两次握手？**

```
若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。

此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。

此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。

但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。
```



### 四次握手

![](https://leanote.com/api/file/getImage?fileId=589f06e6ab644111400008f0)

**第一次挥手**

若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。

- PS1：FIN=1表示该报文段是一个连接释放请求。
- PS2：seq=u，u-1是A向B发送的最后一个字节的序号。

**第二次挥手**

B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：ACK=1，seq=v，ack=u+1。

- PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。
- PS2：seq=v，v-1是B向A发送的最后一个字节的序号。
- PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。

**A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。**

第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。**但B到A方向的连接仍然存在，B可以继续向A发送数据。**

**第三次挥手**

当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。

**第四次挥手**

A收到释放请求后，向B发送确认应答，**此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCP。当B收到确认应答后，也便进入CLOSED状态，撤销TCP。**



##### 四次握手里面有两个问题

**1.为什么建立连接是三次握手，关闭连接是四次握手**

这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，**它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。**但关闭连接时，**当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,**也即<u>你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了</u>，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。



**2.为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？**

为了保证B能收到A的确认应答。若A发完确认应答后直接进入CLOSED状态，**那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。**



### TCP可靠传输的实现

TCP的可靠性表现在：它向应用层提供的数据是 无差错的、有序的、无丢失的，简单的说就是：TCP最终递交给应用层的数据和发送者发送的数据是一模一样的。TCP采用了**流量控制、拥塞控制、连续ARQ**等技术来保证它的可靠性。



ARQ(Automatic Repeat reQuest)自动重传请求。顾名思义，当请求失败时它会自动重传，直到请求被正确接收为止。这种机制保证了每个分组都能被正确接收。停止等待协议是一种ARQ协议。



**停止等待协议的原理**

```
无差错的情况

A向B每发送一个报文，都要停止发送，等待B的确认应答；A只有收到了B的确认应答后才能发送下一个报文。

报文丢失和出现差错的情况

发送者拥有超时计时器。每发送一个报文便会启动超时计时器，等待B的应答。若超时仍未收到应答，则A会重发刚才的报文。

报文出现差错：若B收到报文，但通过检查和字段发现报文在运输途中出现差错，它会直接丢弃该报文，并且不会有任何其他动作。A超时后便会重新发送该报文，直到B正确接收为止。

报文丢失：若报文在途中丢失，B并没有收到报文，因此也不会有任何响应。当A超时后也会重传报文，直到正确接收该报文的应答为止。

综上所述：当报文丢失或出现差错 的情况下，A都会超时重传报文。

```



```
应答丢失 和 应答迟到 的情况

TCP会给每个字节都打上序号，用于判断该报文是否已经接收。

应答丢失：若B正确收到报文，并已经返回应答，但应答在返回途中丢失了。此时A也收不到应答，从而超时重传。紧接着B又收到了该报文。接收者根据序号来判断当前收到的报文是否已经接收，若已接收则直接丢弃，并补上一个确认应答。

应答迟到：若由于网络拥塞，A迟迟收不到B发送的应答，因此会超时重传。B收到该报文后，发现已经接收，便丢弃该报文，并向A补上确认应答。A收到应答后便继续发送下一个报文。但经过了很长时间后，那个失效的应答最终抵达了A，此时A可根据序号判断该报文已经接收，此时只需简单丢弃即可。
```

停止等待协议的注意点

**每发送完一个报文，该报文必须被保留，直到收到确认应答为止。**

**必须给每个报文进行编号。以便按序接收，并判断该报文是否已被接收。**

**必须设置超时计时器。每发送一个报文就要启动计时器，超时就要重发报文。**

计时器的超时时间要大于应答的平均返回时间，否则会出现很多不必要的重传，降低传输效率。但超时时间也不能太长。



**滑动窗口协议（连续ARQ协议）**

- **连续ARQ协议**

  在ARQ协议发送者每次只能发送一个报文，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的报文。这样降低了等待时间，提高了传输效率。

- **累计确认**

  在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个报文就返回一个应答，可以连续收到报文之后统一返回一个应答。这样能节省流量。**TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1**，也表示期望发送者发送的下一个报文的起始字节号。

![](https://leanote.com/api/file/getImage?fileId=58a05a3cab644112350007dc)

发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，**发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的**。发送窗口由三个指针构成：





**流量控制**

- **什么是流量控制？**

  如果发送者发送过快，接收者来不及接收，那么就会有报文丢失。为了避免报文丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。

- **流量控制的目的？**

  流量控制根本目的是防止报文丢失，它是构成TCP可靠性的一方面。

- **如何实现流量控制？**

  由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了报文无差错、有序接收，也实现了流量控制。

- **流量控制引发的死锁**

  当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。

- **持续计时器**

  为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。



**拥塞控制**

- **拥塞控制 和 流量控制 的区别？**

1. 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；

2. 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收。

   PS：**拥塞控制是针对于网络而言的，它是防止往网络中写入太多报文，从而导致网络拥塞的情况；而流量控制是针对接收者的，它是通过控制发送者的发送速度保证接收者能够来得及接收。**

- **拥塞控制的目的？**

1. 缓解网络压力
2. 保证报文按时到达

- **慢开始算法 和 拥塞避免算法**

- 发送方维护一个发送窗口，发送窗口的大小取决于网络的拥塞情况和接收窗口的大小，发送窗口是动态变化的。

- 发送方还维护一个慢开始门限

  1. 发送窗口 < 慢开始门限：使用慢开始算法
  2. 发送窗口 > 慢开始门限：使用拥塞避免算法
  3. 发送窗口 = 慢开始门限：使用慢开始算法或拥塞避免算法

- 算法的具体过程：

  1. 通信开始时，发送方的发送窗口设为1，并发送第一个分组M1；

  2. 接收方收到M1后，返回确认应答，此时发送方发送窗口扩大两倍，并发送M2、M3；（即，发送方每次收到确认应答后，都将发送窗口设为当前值的两倍）

  3. 若发送窗口>慢开始门限，则使用拥塞避免算法，每次收到确认应答后都将发送窗口+1；

  4. 若发送方出现了超时重传，则表明网络出现拥塞，此时： a）慢开始门限设为当前发送窗口的一半 b）发送窗口设为1 c）启用拥塞避免算法

     PS：发送超时重传时，发送窗口有可能已经超过了慢开始门限，也有可能还没超过；此时不管何种情况，都一律启用拥塞避免算法，并执行上述三步操作！

- 慢开始算法的作用：慢开始算法将发送窗口从小扩大，而且按指数级扩大，从而避免一开始就往网络中注入过多的分组从而导致拥塞；它将窗口慢慢扩大的过程其实也在探测网络拥塞情况的过程，当发现出现拥塞时，及时降低发送速度，从而减缓网络拥塞。

- 拥塞避免算法的作用：拥塞避免算法使发送窗口以线性方式增长，而非指数级增长，从而使网络更加不容易发生拥塞。

- AIMD算法（加法增大乘法减小算法）。慢开始算法 和 拥塞避免算法 还有个名称叫做『加法增大乘法减小算法』。

  - 加法增加：指的是拥塞避免算法，使得发送窗口以线性的方式增长；
  - 乘法减小：指的是不管当前正使用慢开始算法还是拥塞避免算法，只要发生拥塞时，慢开始门限将会变成当前窗口的一半。

- **快重传算法 和 快恢复算法**

- 上述慢开始算法和拥塞避免算法能保证网络出现拥塞时进行相应的处理，而快重传和快恢复是一种拥塞预防的方式，此时网络可能尚未出现拥塞，但已经有拥塞的征兆，因此得作出一些预防措施。

- 快重传原理：因为TCP具有累计确认的能力，因此接收者收到一个分组的时候不会立即发出应答，可能需要等待收到多个分组之后再同一发出累计确认。但快重传算法就要求，接收者如果接收到一个乱序的分组的话，就必须立即发出前一个正确分组的确认应答，这样能让发送者尽早地知道有一个分组可能丢失。

- 快恢复原理：当发送者收到同一个分组的三个确认应答后，就基本可以判断这个分组已经丢失了；这时候无需等待超时，直接执行『乘法减小加法增大』：

  1. 将慢开始门限减半
  2. 将发送窗口减半（不设为1）
  3. 使用拥塞避免算法

------