#### 事务的隔离级别

脏读：事务A读到了事务B修改但未提交的数据

不可重复读：事务A读到了事务B修改并提交的数据，A每次查询的结果都受B的影响。

幻读：事务A读到了事务B新增的数据，比如A查到10条数据，统一改同个字段，还没改完，事务B加了一条数据，A提交后，发现改了11条数据，有点懵逼

数据库定义了4个隔离级别：

1. Serializable【可避免脏读，不可重复读，幻读】
2. Repeatable read【可避免脏读，不可重复读】
3. Read committed【可避免脏读】
4. Read uncommitted【级别最低，什么都避免不了】



### 行锁

InnoDB行锁是通过给索引项加锁实现的，如果不通过索引条件检索数据，那么InooDB将对表中所有数据加锁，效果跟表锁一样。

[锁](http://www.cnblogs.com/zhoujinyi/p/3435982.html)

 数据库使用锁是为了支持更好的并发，提供数据的完整性和一致性。InnoDB是一个支持行锁的存储引擎，锁的类型有：共享锁（S）、排他锁（X）、意向共享（IS）、意向排他（IX）。**为了提供更好的并发，InnoDB提供了非锁定读：不需要等待访问行上的锁释放，读取行的一个快照。该方法是通过InnoDB的一个特性：MVCC来实现的。**

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同的数据集的排他锁。
- 排他锁（X）：允许获得排他锁的事务更新数据，但是阻止其他事务获得相同数据集的共享锁和排他锁。

SELECT ... LOCK IN SHARE MODE走的是IS锁(意向共享锁)，即在符合条件的rows上都加了共享锁，这样的话，其他session可以读取这些记录，也可以继续添加IS锁，**但是无法修改这些记录直到你这个加锁的session执行完成(否则直接锁等待超时)。**

SELECT ... FOR UPDATE 走的是IX锁(意向排它锁)，即在符合条件的rows上都加了排它锁，其他session也就无法在这些记录上添加任何的S锁或X锁。如果不存在一致性非锁定读的话，那么其他session是无法读取和修改这些记录的，但是innodb有非锁定读(快照读并不需要加锁)，**for update之后并不会阻塞其他session的快照读取操作，****除了select ...lock in share mode和select ... for update这种显示加锁的查询操作。**

对于insert\update\delete,innodb会自动给涉及的数据加排他锁

对于一般的select语句，innodb不会加任何锁

当然，事务可以显示地加共享锁或者排他锁。

共享锁：select * from table_name where ….lock in share mode

**这个场景用在两张表存在业务关系时的一致性要求**，拿官方例子来说，一个表是child表，一个表是parent表，假设child表的某一列child_id映射到parent表的c_child_id列，那么从业务角度讲，此时我直接insert一条child_id=100记录到child表是存在风险的，因为刚insert的时候可能在parent表里删除了这条c_child_id=100的记录，那么业务数据就存在不一致的风险。

**正确的方法是再插入时执行select * from parent where c_child_id=100 lock in share mode,锁定了parent表的这条记录，然后执行insert into child(child_id) values (100)就ok了。**



但是如果是同一张表的应用场景，举个例子，电商系统中计算一种商品的剩余数量，在产生订单之前需要确认商品数量>=1,产生订单之后应该将商品数量减1。
1 select amount from product where product_name='XX';
2 update product set amount=amount-1 where product_name='XX';



因为如果1查询出amount为1，但是这时正好其他session也买了该商品并产生了订单，那么amount就变成了0，那么这时第二步再执行就有问题。



**for  update适用于操作同一张表时的一致性要求。**

因为InnoDB对于行的查询都是采用了Next-Key Lock的算法，锁定的不是单个值，而是一个范围（GAP）。上面索引值有1，3，5，8，11，其记录的GAP的区间如下：是一个**左开右闭**的空间（原因是默认主键的有序自增的特性，结合后面的例子说明）

行锁分为3种情形：

Record lock：对索引项加锁，即锁定一条记录。

Gap lock：对索引项之间的“间隙”

Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。





### 避免死锁

- 不同程序会并发存取多个表，以相同的顺序访问表。
- 同一个事务中，尽可能做到一次锁定所需要的所有资源
- 程序里面让进程持有锁的时间尽可能短，不让其它进程花太长的时间等待锁被释放。
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率
- 业务允许的话，可以降低事务隔离级别



### 性能

先猜想下性能下降的原因

大概有两个层面，一个是开发层面，一个是服务器层面。

**开发层面就是语句写得不好，太多join关联啊，没建索引，索引建得不合理又或者索引失效。**

**服务器层面，服务器磁盘空间不足，服务器配置参数设置不合理。**



开发层面的话，先看下慢日志，看看哪些sql执行得慢；也看看当前线程情况，使用show processlist看看是否有大量线程处于不正常的状态，有可能正好有一条sql一直在执行，死循环之类的导致性能下降；还有就是show profile，查看哪些sql执行消耗时间长，跟看慢日志差不多。总之先找到具体的sq语句，接着再对具体的sql语句优化。

优化之前，需要explain一下看看这条sql的执行情况，explain之后，看看type字段，**连接类型最差的all跟index，全表扫描，优化目标成range范围查询，ref非唯一性扫描，最好是const常量级别，索引一次就能找到；除了看type字段，还要看extra额外这个字段，看看有没有用到文件排序，有没有用到覆盖索引；**当然rows字段就表示扫描多少行也要注意下。

1.首先看下哪些情况需要建索引

主键，唯一索引

经常做查询条件的字段需要建索引

经常需要排序、分组和统一的字段需要建索引



联合索引，最左前缀才能命中。

前导模糊查询不能使用索引，like语句，百分号放在前面就没有使用到索引

大于小于的查询，看看能不能优化成in查询



覆盖索引，如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。



full index scan  vs full table scan
全索引扫描并不一定就比全表扫描好，**取决于数据存储位置。**
如果数据在内存，那么这两种没有太大区别。
如果数据在磁盘，**全表扫描比全索引扫描要好，这是因为，全表扫描是顺序读数据，sequential read，是顺序IO**
**而全索引扫描，可能会产生随机读(reandom read),随机IO,显然，顺序读要比随机读快很多。**



除了看索引有没有建，也要看索引是否不用建，本来索引是为了查询的，经常增删改，就经常更新的就不用建了，数据就两个值，true 或者false那种也不用建了。

mysql跟myisam的区别，聚焦索引，非聚焦索引，B树，B+树





