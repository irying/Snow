来自https://mp.weixin.qq.com/s/8aI9jS0SXJl5NdcM3TPYuQ

## 单KEY业务

将以“用户中心”为典型的“单KEY”类业务，水平切分的架构点，本文做了这样一些介绍。



### **水平切分方式**：

- 范围法
- 哈希法

```
user-db1：存储0到1千万的uid数据
user-db2：存储1到2千万的uid数据
范围法的优点是：
切分策略简单，根据uid，按照范围，user- center很快能够定位到数据在哪个库上
扩容简单，如果容量不够，只要增加user-db3即可

范围法的不足是：
uid必须要满足递增的特性
数据量不均，新增的user-db3，在初期的数据会比较少
请求量不均，一般来说，新注册的用户活跃度会比较高，故user-db2往往会比user-db1负载要高，导致服务器利用率不平衡
```

```
user-db1：存储uid取模得1的uid数据
user-db2：存储uid取模得0的uid数据
 
哈希法的优点是：
切分策略简单，根据uid，按照hash，user-center很快能够定位到数据在哪个库上
数据量均衡，只要uid是均匀的，数据在各个库上的分布一定是均衡的
请求量均衡，只要uid是均匀的，负载在各个库上的分布一定是均衡的

哈希法的不足是：
扩容麻烦，如果容量不够，要增加一个库，重新hash可能会导致数据迁移，如何平滑的进行数据迁移，是一个需要解决的问题
```

### 水平切分后碰到的问题：

- 通过uid属性查询能直接定位到库，通过非uid属性查询不能定位到库

```

用户登录：通过login_name/phone/email查询用户的实体，1%请求属于这种类型
用户信息查询：登录之后，通过uid来查询用户的实例，99%请求属这种类型

用户侧的查询基本上是单条记录的查询，访问量较大，服务需要高可用，并且对一致性的要求较高。
 
（2）运营侧，后台访问，根据产品、运营需求，访问模式各异，按照年龄、性别、头像、登陆时间、注册时间来进行查询。

运营侧的查询基本上是批量分页的查询，由于是内部系统，访问量很低，对可用性的要求不高，对一致性的要求也没这么严格。
```

 

**这两类业务的架构设计思路**：

- 针对用户侧，应该采用“建立非uid属性到uid的映射关系”的架构方案
- 针对运营侧，应该采用“前台与后台分离”的架构方案

 

**用户前台侧，“建立非uid属性到uid的映射关系”最佳实践**：

- 索引表法：数据库中记录login_name->uid的映射关系
- 缓存映射法：缓存中记录login_name->uid的映射关系
- login_name生成uid
- login_name基因融入uid

 

```
【索引表法】
思路：uid能直接定位到库，login_name不能直接定位到库，如果通过login_name能查询到uid，问题解决

解决方案：
建立一个索引表记录login_name->uid的映射关系
用login_name来访问时，先通过索引表查询到uid，再定位相应的库
索引表属性较少，可以容纳非常多数据，一般不需要分库
如果数据量过大，可以通过login_name来分库

潜在不足：多一次数据库查询，性能下降一倍
```



```
 
【缓存映射法】
思路：访问索引表性能较低，把映射关系放在缓存里性能更佳

解决方案：
login_name查询先到cache中查询uid，再根据uid定位数据库
假设cache miss，采用扫全库法获取login_name对应的uid，放入cache
login_name到uid的映射关系不会变化，映射关系一旦放入缓存，不会更改，无需淘汰，缓存命中率超高
如果数据量过大，可以通过login_name进行cache水平切分

潜在不足：多一次cache查询
```

```
【login_name生成uid】
思路：不进行远程查询，由login_name直接得到uid

解决方案：
在用户注册时，设计函数login_name生成uid，uid=f(login_name)，按uid分库插入数据
用login_name来访问时，先通过函数计算出uid，即uid=f(login_name)再来一遍，由uid路由到对应库

潜在不足：该函数设计需要非常讲究技巧，有uid生成冲突风险
```

```
解决方案：
在用户注册时，设计函数login_name生成3bit基因，login_name_gene=f(login_name)，如上图粉色部分
同时，生成61bit的全局唯一id，作为用户的标识，如上图绿色部分
接着把3bit的login_name_gene也作为uid的一部分，如上图屎黄色部分
生成64bit的uid，由id和login_name_gene拼装而成，并按照uid分库插入数据
用login_name来访问时，先通过函数由login_name再次复原3bit基因，login_name_gene=f(login_name)，通过login_name_gene%8直接定位到库
```

**运营后台侧，“前台与后台分离”最佳实践**：

- 前台、后台系统web/service/db分离解耦，避免后台低效查询引发前台查询抖动
- 可以采用数据冗余的设计方式
- 可以采用“外置索引”（例如ES搜索系统）或者“大数据处理”（例如HIVE）来满足后台变态的查询需求